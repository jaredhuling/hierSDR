% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hier_sphd.R
\name{hier.sphd}
\alias{hier.sphd}
\title{Main hierarchical SDR fitting function}
\usage{
hier.sphd(x, y, z, z.combinations, d, weights = rep(1L, NROW(y)),
  maxit = 250L, h = NULL, opt.method = c("lbfgs2", "lbfgs.x",
  "bfgs.x", "bfgs", "lbfgs", "spg", "ucminf", "CG", "nlm", "nlminb",
  "newuoa"), init.method = c("random", "phd"), vic = TRUE,
  grassmann = TRUE, nn = NULL, nn.try = c(0.15, 0.25, 0.5, 0.75, 0.9,
  0.95), optimize.nn = FALSE, separate.nn = FALSE,
  constrain.none.subpop = TRUE, verbose = TRUE, degree = 2,
  pooled = FALSE, ...)
}
\arguments{
\item{x}{an n x p matrix of covariates, where each row is an observation and each column is a predictor}

\item{y}{vector of responses of length n}

\item{z}{an n x C matrix of binary indicators, where each column is a binary variable indicating the presence
of a binary variable which acts as a stratifying variable. Each combination of all columns of \code{z} pertains
to a different subpopulation. WARNING: do not use too many binary variables in \code{z} or else it will quickly
result in subpopulations with no observations}

\item{z.combinations}{a matrix of dimensions 2^C x C with each row indicating a different combination of the possible
values in \code{z}. Each combination represents a subpopulation. This is necessary because we need to specify a
different structural dimension for each subpopulation, so we need to know the ordering of the subpopulations so we
can assign each one a structural dimension}

\item{d}{an integer vector of length 2^C of structural dimensions. Specified in the same order as the rows in
\code{z.combinations}}

\item{weights}{vector of observation weights}

\item{maxit}{maximum number of iterations}

\item{h}{bandwidth parameter. By default, a reasonable choice is selected automatically}

\item{opt.method}{optimization method to use. Available choices are
\code{c("lbfgs2", "lbfgs.x", "bfgs.x", "bfgs", "lbfgs", "spg", "ucminf", "CG", "nlm", "nlminb", "newuoa")}}

\item{init.method}{method for parameter initialization. Either \code{"random"} for random initialization or \code{"phd"}
for a principle Hessian directions initialization approach}

\item{vic}{logical value of whether or not to compute the VIC criterion for dimension determination}

\item{grassmann}{logical value of whether or not to enforce parameters to be on the Grassmann manifold}

\item{nn}{nearest neighbor parameter for \code{\link[locfit]{locfit.raw}}}

\item{nn.try}{vector of nearest neighbor parameters for \code{\link[locfit]{locfit.raw}} to try in random initialization}

\item{optimize.nn}{should \code{nn} be optimized? Not recommended}

\item{separate.nn}{should each subpopulation have its own \code{nn}? If \code{TRUE}, optimization takes
much longer. It is rarely better, so recommended to set to \code{FALSE}}

\item{constrain.none.subpop}{should the "none" subpopulation be constrained to be contained in every other subpopulation's
dimension reduction subspace? Recommended to set to \code{TRUE}}

\item{verbose}{should results be printed along the way?}

\item{degree}{degree of kernel to use}

\item{pooled}{should the estimator be a pooled estimator?}

\item{...}{extra arguments passed to \code{\link[locfit]{locfit.raw}}}
}
\description{
fits hierarchical SDR models
}
\examples{

library(hierSDR)

}
